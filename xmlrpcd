#!/usr/bin/perl

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

use YAML qw/LoadFile/;

use App::Daemon qw/daemonize/;
use Log::Log4perl;
use Authen::Simple;

#-----------------------------------------------------------------------------
# load configuration

$App::Daemon::pidfile = 'run/xmlrpcd.pid';
$App::Daemon::l4p_conf = 'logging.conf';

my $options = {};

my $opts_file = App::Daemon::find_option("--config" => 1);
if (defined $opts_file) {
  $options = LoadFile($opts_file);
}

#-----------------------------------------------------------------------------
# change UID/GID, if applicable

my $uid = App::Daemon::find_option("--user" => 1);
my $gid = App::Daemon::find_option("--group" => 1);

if (defined $gid) {
  $gid = getgrnam $gid unless $gid =~ /^\d+$/;
}
if (defined $uid) {
  $uid = getpwnam $uid unless $uid =~ /^\d+$/;
  if (not defined $gid) {
    $gid = (getpwuid $uid)[3];
  }
}

if (defined $gid) {
  $( = $) = "$gid $gid";
}
if (defined $uid) {
  $< = $> = $uid;
}

#-----------------------------------------------------------------------------

daemonize();

my $logger = Log::Log4perl::get_logger("initialization");

#-----------------------------------------------------------------------------
# prepare RPC mapping

my $rpc_hash = {};

for my $glob (@{ $options->{"methods"} }) {
  for my $file (glob $glob) {
    $logger->debug("Loading $file");

    my $load = load_method($file);
    $rpc_hash->{"$load->{schema}.$load->{method}"} = $load->{"proc"};
  }
}

#-----------------------------------------------------------------------------
# prepare authentication subsystem

my $auth = new Authen::Simple(
  auth_module_init($options->{'auth_method'}, $options->{'auth_params'})
);

#-----------------------------------------------------------------------------

$logger = Log::Log4perl::get_logger("http");

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $options->{"ssl_cert_file"},
  SSL_key_file  => $options->{"ssl_key_file"},
  LocalPort => $options->{"listen_port"},
  LocalAddr => $options->{"listen_addr"},
  Listen => 1,
  ReuseAddr => 1,
) or $logger->logdie("Socket listening error: ", $!);

my $rpc_server = new Frontier::RPC2();

my $workers = new Proc::Queue();

CLIENT:
while (1) {
  my $client = $daemon->accept or next CLIENT;

  if ($workers->spawn == 0) {
    process_client($client, $auth, $rpc_server, $rpc_hash);
    exit 0;
  }
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

sub process_client {
  my ($client, $auth, $rpc_server, $rpc_hash) = @_;

  my $logger = Log::Log4perl::get_logger("client");

  REQUEST:
  while (my $req = $client->get_request) {
    $logger->debug("Another request");

    if ($req->method ne 'POST') {
      $logger->info("HTTP request ", $req->method, ": denying");
      $client->send_error(RC_FORBIDDEN);
      next REQUEST;
    }

    # XXX: authenticate
    my $auth_user = authenticate($req, $auth);
    if (not defined $auth_user) {
      $logger->debug("Unauthorized request");
      my $resp = new HTTP::Response(401, 'Unauthorized');
      $resp->header('WWW-Authenticate' => 'Basic realm=""');

      $client->send_response($resp);
      next REQUEST;
    }

    $logger->debug("Request authorized (user ", $auth_user, ")");

    my $xml_resp = $rpc_server->serve(
      $req->content,
      $rpc_hash,
    );

    my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

    $client->send_response($resp);
  }
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req, $auth) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  my $logger = Log::Log4perl::get_logger("auth");

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  $logger->debug("Requested user: ", $user);
  if ($auth->authenticate($user, $pass)) {
    $logger->debug("Authentication success");
    return $user;
  }

  return undef;
}

#-----------------------------------------------------------------------------

sub auth_module_init {
  my ($module, $options) = @_;

  die "Undefined authentication module name" if not defined $module;
  if ($module !~ /^[a-zA-Z_0-9:]+$/) {
    die "Invalid authentication module name: $module";
  }

  my $instance;
  eval "
    require $module;
    \$instance = ${module}->new(%\$options);
  ";
  die $@ if $@;

  return $instance;
}

#-----------------------------------------------------------------------------

sub load_method {
  my ($path) = @_;

  my $package = $path;
  $package =~ s/\.pm$//;

  ($package, my $method) = (split m[/+], $package)[-2, -1];

  if ("${package}::${method}" !~ /^[a-zA-Z0-9_]+::[a-zA-Z0-9_]+$/) {
    die "Path $path translates into incorrect package name: ${package}::${method}";
  }

  my $sub;
  eval "
    package rpcmethod::$package;
    require \$path;
    \$sub = \\&entry_point;
  ";
  die $@ if $@;

  return {
    schema => $package,
    method => $method,
    proc   => $sub,
  };
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

package Proc::Queue;

use POSIX qw/:sys_wait_h/;

sub new {
  my ($class, %args) = @_;

  my $self = {
    queue => [],
    max_len => int($args{max_len} // 0),
  };

  return bless $self, $class;
}

sub reap {
  my ($self) = @_;

  CHILD:
  while ((my $kid = waitpid(-1, WNOHANG)) > 0) {
    for (my $i = 0; $i < @{ $self->{queue} }; ++$i) {
      if ($self->{queue}[$i] == $kid) {
        splice @{ $self->{queue} }, $i, 1;
        next CHILD;
      }
    }
  }
}

sub spawn {
  my ($self) = @_;

  if ($self->{max_len} > 0) {
    while ($self->length >= $self->{max_len}) {
      sleep 1;
    }
  }

  my $pid = fork;
  if (not defined $pid) {
    die "Can't fork(): $!";
  }

  if ($pid > 0) {
    push @{ $self->{queue} }, $pid;
  }

  return $pid;
}

sub length {
  my ($self) = @_;

  return scalar @{ $self->{queue} };
}

#-----------------------------------------------------------------------------
# vim:ft=perl
