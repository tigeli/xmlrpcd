#!/usr/bin/perl

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

use YAML qw/LoadFile/;

use App::Daemon qw/daemonize/;
use Log::Log4perl;
use Authen::Simple;

#-----------------------------------------------------------------------------
# load configuration

$App::Daemon::pidfile = '/var/run/xmlrpcd/xmlrpcd.pid';
$App::Daemon::l4p_conf = '/etc/xmlrpcd/logging.conf';
my $default_config = '/etc/xmlrpcd/xmlrpcd.conf';
my $config_file = $default_config;

my $opts_file = App::Daemon::find_option("--config" => 1);
if (defined $opts_file) {
  $config_file = $opts_file;
}

#-----------------------------------------------------------------------------
# UID/GID stuff

# I need to have possibility to change UID/GID, so this daemon needs to run as
# root
unshift @ARGV, "-u", "root";

# get command-line specified default IDs
our $DEFAULT_UID = App::Daemon::find_option("--default-user" => 1) || 'xmlrpcd';
our $DEFAULT_GID = App::Daemon::find_option("--default-group" => 1);

#-----------------------------------------------------------------------------

if (!-f $config_file || !-r _) {
  die "Need a config file to run. Either provide one as --config option or create $default_config\n";
}

my $options = LoadFile($config_file);

#-----------------------------------------------------------------------------

daemonize();

my $logger = Log::Log4perl::get_logger("initialization");

#-----------------------------------------------------------------------------
# prepare RPC mapping

my $public = {};
my $rpc_hash = {};

for my $cat (qw/auth public/) {
  next if not exists $options->{"methods"}{$cat};
  for my $glob (@{ $options->{"methods"}{$cat} }) {
    for my $file (glob $glob) {
      $logger->debug("Loading $file");

      my $load = load_method($file);
      my $method_name = "$load->{schema}.$load->{method}";

      if ($cat eq 'public') {
        $public->{$method_name} = 1;
      }
      if (not exists $rpc_hash->{$method_name}) {
        $rpc_hash->{$method_name} = sub {
          my @params = prepare_environment($load);
          $load->{"proc"}(@params, @_);
        };
      }
    }
  }
}

#-----------------------------------------------------------------------------
# prepare authentication subsystem

my $auth = new Authen::Simple(
  auth_module_init($options->{'auth_method'}, $options->{'auth_params'})
);

#-----------------------------------------------------------------------------

$logger = Log::Log4perl::get_logger("server");

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $options->{"ssl_cert_file"},
  SSL_key_file  => $options->{"ssl_key_file"},
  LocalPort => $options->{"listen_port"},
  LocalAddr => $options->{"listen_addr"},
  Listen => 1,
  ReuseAddr => 1,
) or $logger->logdie("Socket listening error: ", $!);

my $rpc_server = new Frontier::RPC2();

my $workers = new Proc::Queue();
$SIG{CHLD} = sub { $workers->reap };
$SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
  my ($signal) = @_;

  my $logger = Log::Log4perl::get_logger("server");
  $logger->info("Terminating on signal ", $signal);

  $workers->killall;
  exit;
};

# I don't care about broken pipe (mostly communication with connecting agents)
$SIG{PIPE} = 'IGNORE';

CLIENT:
while (1) {
  my $client = $daemon->accept or next CLIENT;

  if ($workers->spawn == 0) {
    # when daemon gets restarted while some client was processed, (new) daemon
    # will be able to listen() on the socket
    close $daemon;
    # in child process, `` should return status in $? variable normally
    $SIG{CHLD} = "DEFAULT";
    process_client($client, $auth, $rpc_server, $rpc_hash, $public);
    exit 0;
  }
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

sub process_client {
  my ($client, $auth, $rpc_server, $rpc_hash, $public) = @_;

  # on SIGTERM client handler should finish processing current request and
  # THEN exit
  my $continue_processing = 1;
  $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub { $continue_processing = 0 };

  my $logger = Log::Log4perl::get_logger("client");

  my $req = $client->get_request;
  if (not $req) {
    return;
  }

  $logger->debug("Another request");

  if ($req->method ne 'POST') {
    $logger->info("HTTP request ", $req->method, ": denying");
    $client->send_error(RC_FORBIDDEN);
    return;
  }

  my $req_decoded = $rpc_server->decode($req->content);

  my $auth_user;
  if (not $public->{$req_decoded->{method_name}}) {
    # XXX: authenticate if method was not marked as public

    $logger->debug("Request for ", $req_decoded->{method_name},
                   " requires authentication");

    $auth_user = authenticate($req, $auth);
    if (not defined $auth_user) {
      $logger->debug("Unauthorized request");
      my $resp = new HTTP::Response(401, 'Unauthorized');
      $resp->header('WWW-Authenticate' => 'Basic realm=""');

      $client->send_response($resp);
      return;
    }

    $logger->debug("Request authorized (user ", $auth_user, ")");
  }

  my $xml_resp = do {
    # XXX: there's no convenient way of communicating with method handlers,
    # what implies that I can't pass any additional arguments (like $auth_user
    # or client IP address) to prepare_environment() function
    local our $REQUEST_CALLER_ADDRESS  = $client->peerhost;
    local our $REQUEST_CALLER_USERNAME = $auth_user;
    $rpc_server->serve($req->content, $rpc_hash);
  };

  my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

  $client->send_response($resp);
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req, $auth) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  my $logger = Log::Log4perl::get_logger("auth");

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  $logger->debug("Requested user: ", $user);
  if ($auth->authenticate($user, $pass)) {
    $logger->debug("Authentication success");
    return $user;
  }

  return undef;
}

#-----------------------------------------------------------------------------

sub auth_module_init {
  my ($module, $options) = @_;

  die "Undefined authentication module name" if not defined $module;
  if ($module !~ /^[a-zA-Z_0-9:]+$/) {
    die "Invalid authentication module name: $module";
  }

  my $instance;
  eval "
    require $module;
    \$instance = ${module}->new(%\$options);
  ";
  die $@ if $@;

  return $instance;
}

#-----------------------------------------------------------------------------

sub load_method {
  my ($path) = @_;

  my $package = $path;
  $package =~ s/\.pm$//;

  ($package, my $method) = (split m[/+], $package)[-2, -1];

  if ("${package}::${method}" !~ /^[a-zA-Z0-9_]+::[a-zA-Z0-9_]+$/) {
    die "Path $path translates into incorrect package name: ${package}::${method}";
  }

  my $sub;
  my $pkg;
  eval "
    package rpcmethod::${package}::${method};
    require \$path;
    \$sub = \\&entry_point;
    \$pkg = \\%rpcmethod::${package}::${method}::;
  ";
  die $@ if $@;

  my $result = {
    schema => $package,
    method => $method,
    proc   => $sub,
  };

  # undef if no symbol
  sub take_symbol_scalar_value {
    my ($package, $symbol) = @_;

    # symbol has to exist
    return if not defined $package->{$symbol};
    # symbol has to contain a scalar
    return if not defined *{ $package->{$symbol} }{SCALAR};
    # reference to scalar's value (reference to anonymous scalar, if the
    # scalar wasn't created yet)
    my $glob_ref = *{ $package->{$symbol} }{SCALAR};

    return $glob_ref && $$glob_ref;
  }

  my %scalars = qw(
    uid       RPC_UID
    gid       RPC_GID
    params    RPC_PARAMS
  );
  while (my ($key, $symbol) = each %scalars) {
    $result->{$key} = take_symbol_scalar_value($pkg, $symbol);
  }

  return $result;
}

# $env is the same hash as returned by load_method()
sub prepare_environment {
  my ($env) = @_;

  #---------------------------------------------------------------------------
  # change UID/GID from root to appropriate ones

  sub resolve_uid_gid {
    my ($uid, $gid) = @_;

    $uid = getpwnam $uid unless $uid =~ /^\d+$/;

    if (defined $gid) {
      $gid = getgrnam $gid unless $gid =~ /^\d+$/;
    } else {
      $gid = (getpwuid $uid)[3];
    }

    return ($uid, $gid);
  }

  my ($uid, $gid) = ($DEFAULT_UID, $DEFAULT_GID);
  if (defined $env->{uid}) {
    ($uid, $gid) = ($env->{uid}, $env->{gid}); # even if GID is undef
  }
  ($uid, $gid) = resolve_uid_gid($uid, $gid);

  $( = $) = "$gid $gid";
  $< = $> = $uid;

  #---------------------------------------------------------------------------
  # append additional method arguments, as defined in RPC_PARAMS in method
  # definition

  my @additional_args;

  # for information on what is in these variables, see process_client()
  # function
  our $REQUEST_CALLER_ADDRESS;
  our $REQUEST_CALLER_USERNAME;

  for my $param (@{ $env->{params} }) {
    if ($param eq 'user') {
      # authenticated user
      push @additional_args, $REQUEST_CALLER_USERNAME;
    } elsif ($param eq 'address') {
      # IP address of caller
      push @additional_args, $REQUEST_CALLER_ADDRESS;
    } else {
      # unknown parameter; leave undef
      # TODO: warn
      push @additional_args, undef;
    }
  }

  return @additional_args;
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

package Proc::Queue;

use POSIX qw/:sys_wait_h/;

sub new {
  my ($class, %args) = @_;

  my $self = {
    queue => [],
    max_len => int($args{max_len} || 0),
  };

  return bless $self, $class;
}

sub killall {
  my ($self, $signal) = @_;

  if (not defined $signal) {
    $signal = 'TERM';
  }

  kill $signal, @{ $self->{queue} };
  $self->reap;
}

sub reap {
  my ($self) = @_;

  CHILD:
  while ((my $kid = waitpid(-1, WNOHANG)) > 0) {
    #if ($? != 0) {
    #  printf STDERR "Error code: %d (signal %d)\n", $? >> 8, $? & 0xff;
    #}
    for (my $i = 0; $i < @{ $self->{queue} }; ++$i) {
      if ($self->{queue}[$i] == $kid) {
        splice @{ $self->{queue} }, $i, 1;
        next CHILD;
      }
    }
  }
}

sub spawn {
  my ($self) = @_;

  if ($self->{max_len} > 0) {
    while ($self->length >= $self->{max_len}) {
      sleep 1;
    }
  }

  my $pid = fork;
  if (not defined $pid) {
    die "Can't fork(): $!";
  }

  if ($pid > 0) {
    push @{ $self->{queue} }, $pid;
  }

  return $pid;
}

sub length {
  my ($self) = @_;

  return scalar @{ $self->{queue} };
}

#-----------------------------------------------------------------------------
# vim:ft=perl
