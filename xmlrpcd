#!/usr/bin/perl

=head1 NAME

xmlrpcd - XML-RPC daemon

=cut

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

use YAML qw/LoadFile/;

use App::Daemon qw/daemonize/;
use Log::Log4perl;
use Authen::Simple;

#-----------------------------------------------------------------------------
# load configuration

$App::Daemon::pidfile = '/var/run/xmlrpcd/xmlrpcd.pid';
$App::Daemon::l4p_conf = '/etc/xmlrpcd/logging.conf';
my $default_config = '/etc/xmlrpcd/xmlrpcd.conf';
my $config_file = $default_config;

my $opts_file = App::Daemon::find_option("--config" => 1);
if (defined $opts_file) {
  $config_file = $opts_file;
}

=head1 SYNOPSIS

xmlrpcd [--config xmlrpcd.conf] [-l4p logging.conf]
        [--default-user username] [--default-group groupname]
        [-p pidfile.pid] [-X]

xmlrpcd --help

=cut

my $help = App::Daemon::find_option("--help");
if ($help) {
  printf "Usage: %s [options]\n", (split m[/], $0)[-1];
  printf "\nOptions:\n";
  printf "--config %s\n", $default_config;
  printf "  configuration file\n";
  printf "-l4p %s\n", $App::Daemon::l4p_conf;
  printf "  Log::Log4perl configuration file\n";
  printf "--default-user xmlrpcd\n";
  printf "  default UID to run methods as (method can override this)\n";
  printf "--default-group xmlrpcd\n";
  printf "  default GID to run methods as (method can override this)\n";
  printf "-p %s\n", $App::Daemon::pidfile;
  printf "  file to save PID\n";
  printf "-X\n";
  printf "  option prevents %s from detaching and sets general debugging stuff\n",
         (split m[/], $0)[-1];

  exit 0;
}

=pod {{{

=head1 DESCRIPTION

xmlrpcd is a general dispatcher for XML-RPC requests. Its main purpose is to
enable system administrator to define a procedure (possibly parametrized) and
to make it executed from remote host.

All this sounds like "write a script and call it using SSH", but there are
several catches with that approach:

=over

=item user account and privileges

You need to maintain one more usable account, what adds complexity to your
servers network. Also, casual user account could have too little privileges to
perform necessary tasks. Suddenly you find yourself maintaining bunch of
L<sudoers(5)> entries, what makes your network even more complex.

You could also use I<root> account to log into, but this is generally a bad
practice and it's not as elegant as it could be.

=item authentication

Maintaining host keys (F<~/.ssh/known_hosts>) and user keys in SSH
(F<~/.ssh/authorized_keys>) is difficult, as there is no hierarchy and each
key needs to be added on each host. This is a problem for both host
authentication on client side and for user authentication on server side.

=item parametrization

You can't easily limit and/or validate arguments passed to called script.

=back

All that is solved by xmlrpcd. You define Perl functions that can be called
from remote. The functions take parameters that can be thoroughly checked.
Functions are executed with UID/GID as given in their description, without
requiring a login-enabled shell. Server verification is based on SSL/TLS, so
you can use full-blown X.509 infrastructure for this, while client
verification is HTTP-AUTH based, and for storing passwords you can use
everything from simple L<htpasswd(1)> files to LDAP, RADIUS and Kerberos.

=head1 CONFIGURATION

xmlrpcd configuration is split into two parts: execution and logging.

=head2 Logging Configuration

Logging is entirely configured used L<Log::Log4perl(3)> syntax. See
L<Log::Log4perl(3)> documentation for details.

=head2 Execution Configuration

This part of configuration is defined in F<xmlrpcd.conf>. This is YAML
formatted file. Example:

  ssl_cert_file: /etc/xmlrpcd/ssl/server.cert.pem
  ssl_key_file:  /etc/xmlrpcd/ssl/server.key.pem
  listen_port: 3033
  #listen_addr: localhost

  auth_method: Authen::Simple::Passwd
  auth_params:
    path: /var/lib/xmlrpcd/passwords.htpasswd

  methods:
    auth:
      - "/var/lib/xmlrpcd/procedures/private/*.pm"
      - "/var/lib/xmlrpcd/anothers/admin/*.pm"
    public:
      - "/var/lib/xmlrpcd/procedures/public/*.pm"

The first part specifies SSL key and certificate, and address to listen on.

Next uses module L<Authen::Simple::Passwd(3)> to authenticate clients. In this
case, they will be authenticated against F<passwords.htpasswd> file. You can
use any L<Authen::Simple(3)> compatible module. Parameters to C<new()> method
can be specified in I<auth_params>.

The last part says where are the RPC procedures (or "methods") (shell
wildcards are accepted here), which of them need to be executed on
authenticated RPC call, and which are free to execute by anyone that can
connect to xmlrpcd.

B<NOTE>: You can safely duplicate methods in both sections. For example,
all F</var/lib/xmlrpcd/procedures/foo/*.pm> methods can be callable (requiring
password from client), but additionally F<.../foo/public.pm> needs to be
callable without HTTP authentication. Just put F<.../foo/*.pm> in "auth"
section and F<.../foo/public.pm> in "public".

=head2 RPC Method API

TODO: remote procedure name

=head3 C<entry_point()>

=head3 C<$RPC_UID>, C<$RPC_GID>

=head3 C<$RPC_PARAMS>

=head3 Local and global variables in package

=head1 SEE ALSO

L<xmlrpcaller(1)>,
L<Frontier::Client(3)>,
L<Log::Log4perl(3)>,
L<Authen::Simple(3)>

=pod }}}

=cut

#-----------------------------------------------------------------------------
# UID/GID stuff

# I need to have possibility to change UID/GID, so this daemon needs to run as
# root
unshift @ARGV, "-u", "root";

# get command-line specified default IDs
our $DEFAULT_UID = App::Daemon::find_option("--default-user" => 1) || 'xmlrpcd';
our $DEFAULT_GID = App::Daemon::find_option("--default-group" => 1);

#-----------------------------------------------------------------------------

if (!-f $config_file || !-r _) {
  die "Need a config file to run. Either provide one as --config option or create $default_config\n";
}

my $options = LoadFile($config_file);

#-----------------------------------------------------------------------------

daemonize();
# XXX: due to bug in App::Daemon, I need to take care on my own to set proper
# permissions; PID file with 0666 perms is a simple way to fall victim to DoS
# attack (echo 1 > $pidfile, wait for admin to /etc/init.d/xmlrpcd stop);
# while this still leaves race condition, it's way better than simply keep
# 0666 perms
chmod 0644, $App::Daemon::pidfile;

my $logger = Log::Log4perl::get_logger("initialization");

#-----------------------------------------------------------------------------
# prepare RPC mapping

my $public = {};
my $rpc_hash = {};

for my $cat (qw/auth public/) {
  next if not exists $options->{"methods"}{$cat};
  for my $glob (@{ $options->{"methods"}{$cat} }) {
    for my $file (glob $glob) {
      $logger->debug("Loading $file");

      my $load = load_method($file);
      my $method_name = "$load->{schema}.$load->{method}";

      if ($cat eq 'public') {
        $public->{$method_name} = 1;
      }
      if (not exists $rpc_hash->{$method_name}) {
        $rpc_hash->{$method_name} = sub {
          my @params = prepare_environment($load);
          $load->{"proc"}(@params, @_);
        };
      }
    }
  }
}

#-----------------------------------------------------------------------------
# prepare authentication subsystem

my $auth = new Authen::Simple(
  auth_module_init($options->{'auth_method'}, $options->{'auth_params'})
);

#-----------------------------------------------------------------------------

$logger = Log::Log4perl::get_logger("server");

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $options->{"ssl_cert_file"},
  SSL_key_file  => $options->{"ssl_key_file"},
  LocalPort => $options->{"listen_port"},
  LocalAddr => $options->{"listen_addr"},
  Listen    => 64,
  ReuseAddr => 1,
) or $logger->logdie("Socket listening error: ", $!);

my $rpc_server = new Frontier::RPC2();

my $workers = new Proc::Queue();
$SIG{CHLD} = sub { $workers->reap };
$SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
  my ($signal) = @_;

  my $logger = Log::Log4perl::get_logger("server");
  $logger->info("Terminating on signal ", $signal);

  $workers->killall;
  exit;
};

# I don't care about broken pipe (mostly communication with connecting agents)
$SIG{PIPE} = 'IGNORE';

CLIENT:
while (1) {
  my $client = $daemon->accept or next CLIENT;

  if ($workers->spawn == 0) {
    # when daemon gets restarted while some client was processed, (new) daemon
    # will be able to listen() on the socket
    close $daemon;
    # in child process, `` should return status in $? variable normally
    $SIG{CHLD} = "DEFAULT";
    process_client($client, $auth, $rpc_server, $rpc_hash, $public);
    exit 0;
  }
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

sub process_client {
  my ($client, $auth, $rpc_server, $rpc_hash, $public) = @_;

  $0 = sprintf '[xmlrpcd (?@%s) ?.?]', $client->peerhost;

  # on SIGTERM client handler should finish processing current request and
  # THEN exit
  my $continue_processing = 1;
  $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub { $continue_processing = 0 };
  $SIG{ALRM} = sub { die "timeout\n" };

  my $logger = Log::Log4perl::get_logger("client");

  my $req; # HTTP::Request
  eval {
    alarm 60;
    $req = $client->get_request;
    alarm 0;
  };
  if (not $req) {
    if ($@ eq "timeout\n") {
      $logger->info("Timeout while waiting for request from client ",
                    $client->peerhost);
    }
    return;
  }

  $logger->debug("Another request");

  if ($req->method ne 'POST') {
    $logger->info("HTTP request ", $req->method, ": denying");
    eval {
      alarm 60;
      $client->send_error(RC_FORBIDDEN);
      alarm 0;
    };
    # don't care about timeouts here
    return;
  }

  my $req_decoded = $rpc_server->decode($req->content);

  $0 = sprintf '[xmlrpcd (?@%s) %s]',
               $client->peerhost, $req_decoded->{method_name};

  my $auth_user;
  if (not $public->{$req_decoded->{method_name}}) {
    # XXX: authenticate if method was not marked as public

    $logger->debug("Request for ", $req_decoded->{method_name},
                   " requires authentication");

    $auth_user = authenticate($req, $auth);
    if (not defined $auth_user) {
      $logger->debug("Unauthorized request");
      my $resp = new HTTP::Response(401, 'Unauthorized');
      $resp->header('WWW-Authenticate' => 'Basic realm=""');

      eval {
        alarm 60;
        $client->send_response($resp);
        alarm 0;
      };
      # don't care about timeouts here
      return;
    }

    $logger->debug("Request authorized (user ", $auth_user, ")");
  }
  $0 = sprintf '[xmlrpcd (%s@%s) %s]',
               (defined $auth_user ? $auth_user : "<anonymous>"),
               $client->peerhost, $req_decoded->{method_name};

  my $xml_resp = do {
    # XXX: there's no convenient way of communicating with method handlers,
    # what implies that I can't pass any additional arguments (like $auth_user
    # or client IP address) to prepare_environment() function
    local our $REQUEST_CALLER_ADDRESS  = $client->peerhost;
    local our $REQUEST_CALLER_USERNAME = $auth_user;
    local our $REQUEST_CALLER_URI      = $req->uri;
    $rpc_server->serve($req->content, $rpc_hash);
  };

  my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

  eval {
    alarm 60;
    $client->send_response($resp);
    alarm 0;
  };
  if ($@ && $@ eq "timeout\n") {
    $logger->info("Timeout while sending response to ", $client->peerhost);
  }
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req, $auth) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  my $logger = Log::Log4perl::get_logger("auth");

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  $logger->debug("Requested user: ", $user);
  if ($auth->authenticate($user, $pass)) {
    $logger->debug("Authentication success");
    return $user;
  }

  return undef;
}

#-----------------------------------------------------------------------------

sub auth_module_init {
  my ($module, $options) = @_;

  die "Undefined authentication module name" if not defined $module;
  if ($module !~ /^[a-zA-Z_0-9:]+$/) {
    die "Invalid authentication module name: $module";
  }

  my $instance;
  eval "
    require $module;
    \$instance = ${module}->new(%\$options);
  ";
  die $@ if $@;

  return $instance;
}

#-----------------------------------------------------------------------------

sub load_method {
  my ($path) = @_;

  my $package = $path;
  $package =~ s/\.pm$//;

  ($package, my $method) = (split m[/+], $package)[-2, -1];

  if ("${package}::${method}" !~ /^[a-zA-Z0-9_]+::[a-zA-Z0-9_]+$/) {
    die "Path $path translates into incorrect package name: ${package}::${method}";
  }

  my $sub;
  my $pkg;
  eval "
    package rpcmethod::${package}::${method};
    require \$path;
    \$sub = \\&entry_point;
    \$pkg = \\%rpcmethod::${package}::${method}::;
  ";
  die $@ if $@;

  my $result = {
    schema => $package,
    method => $method,
    proc   => $sub,
  };

  # undef if no symbol
  sub take_symbol_scalar_value {
    my ($package, $symbol) = @_;

    # symbol has to exist
    return if not defined $package->{$symbol};
    # symbol has to contain a scalar
    return if not defined *{ $package->{$symbol} }{SCALAR};
    # reference to scalar's value (reference to anonymous scalar, if the
    # scalar wasn't created yet)
    my $glob_ref = *{ $package->{$symbol} }{SCALAR};

    return $glob_ref && $$glob_ref;
  }

  my %scalars = qw(
    uid       RPC_UID
    gid       RPC_GID
    params    RPC_PARAMS
  );
  while (my ($key, $symbol) = each %scalars) {
    $result->{$key} = take_symbol_scalar_value($pkg, $symbol);
  }

  return $result;
}

# $env is the same hash as returned by load_method()
sub prepare_environment {
  my ($env) = @_;

  #---------------------------------------------------------------------------
  # change UID/GID from root to appropriate ones

  sub resolve_uid_gid {
    my ($uid, $gid) = @_;

    $uid = getpwnam $uid unless $uid =~ /^\d+$/;

    if (defined $gid) {
      $gid = getgrnam $gid unless $gid =~ /^\d+$/;
    } else {
      $gid = (getpwuid $uid)[3];
    }

    return ($uid, $gid);
  }

  my ($uid, $gid) = ($DEFAULT_UID, $DEFAULT_GID);
  if (defined $env->{uid}) {
    ($uid, $gid) = ($env->{uid}, $env->{gid}); # even if GID is undef
  }
  ($uid, $gid) = resolve_uid_gid($uid, $gid);

  $( = $) = "$gid $gid";
  $< = $> = $uid;

  #---------------------------------------------------------------------------
  # append additional method arguments, as defined in RPC_PARAMS in method
  # definition

  my @additional_args;

  # for information on what is in these variables, see process_client()
  # function
  our $REQUEST_CALLER_ADDRESS;
  our $REQUEST_CALLER_USERNAME;
  our $REQUEST_CALLER_URI;

  for my $param (@{ $env->{params} }) {
    if ($param eq 'user') {
      # authenticated user
      push @additional_args, $REQUEST_CALLER_USERNAME;
    } elsif ($param eq 'address') {
      # IP address of caller
      push @additional_args, $REQUEST_CALLER_ADDRESS;
    } elsif ($param eq 'uri') {
      # URI that was requested
      push @additional_args, $REQUEST_CALLER_URI;
    } else {
      # unknown parameter; leave undef
      # TODO: warn
      push @additional_args, undef;
    }
  }

  return @additional_args;
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

package Proc::Queue;

use POSIX qw/:sys_wait_h/;

sub new {
  my ($class, %args) = @_;

  my $self = {
    queue => [],
    max_len => int($args{max_len} || 0),
  };

  return bless $self, $class;
}

sub killall {
  my ($self, $signal) = @_;

  if (not defined $signal) {
    $signal = 'TERM';
  }

  kill $signal, @{ $self->{queue} };
  $self->reap;
}

sub reap {
  my ($self) = @_;

  CHILD:
  while ((my $kid = waitpid(-1, WNOHANG)) > 0) {
    #if ($? != 0) {
    #  printf STDERR "Error code: %d (signal %d)\n", $? >> 8, $? & 0xff;
    #}
    for (my $i = 0; $i < @{ $self->{queue} }; ++$i) {
      if ($self->{queue}[$i] == $kid) {
        splice @{ $self->{queue} }, $i, 1;
        next CHILD;
      }
    }
  }
}

sub spawn {
  my ($self) = @_;

  if ($self->{max_len} > 0) {
    while ($self->length >= $self->{max_len}) {
      sleep 1;
    }
  }

  my $pid = fork;
  if (not defined $pid) {
    die "Can't fork(): $!";
  }

  if ($pid > 0) {
    push @{ $self->{queue} }, $pid;
  }

  return $pid;
}

sub length {
  my ($self) = @_;

  return scalar @{ $self->{queue} };
}

#-----------------------------------------------------------------------------
# vim:ft=perl
