#!/usr/bin/perl

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

use YAML qw/LoadFile/;

use App::Daemon qw/daemonize/;
use Log::Log4perl;
use Authen::Simple;

#-----------------------------------------------------------------------------
# load configuration

$App::Daemon::pidfile = '/var/run/xmlrpcd/xmlrpcd.pid';
$App::Daemon::l4p_conf = '/etc/xmlrpcd/logging.conf';
my $default_config = '/etc/xmlrpcd/xmlrpcd.conf';
my $config_file = $default_config;

my $opts_file = App::Daemon::find_option("--config" => 1);
if (defined $opts_file) {
  $config_file = $opts_file;
}

#-----------------------------------------------------------------------------
# change UID/GID, if applicable

my $uid = App::Daemon::find_option("--user" => 1);
my $gid = App::Daemon::find_option("--group" => 1);

if (defined $gid) {
  $gid = getgrnam $gid unless $gid =~ /^\d+$/;
}
if (defined $uid) {
  $uid = getpwnam $uid unless $uid =~ /^\d+$/;
  if (not defined $gid) {
    $gid = (getpwuid $uid)[3];
  }
}

if (defined $gid) {
  $( = $) = "$gid $gid";
}
if (defined $uid) {
  $< = $> = $uid;

  if ($uid eq 'root' || $uid eq '0') {
    unshift @ARGV, "-u", "root";
  }
}

#-----------------------------------------------------------------------------

if (!-f $config_file || !-r _) {
  die "Need a config file to run. Either provide one as --config option or create $default_config\n";
}

my $options = LoadFile($config_file);

#-----------------------------------------------------------------------------

daemonize();

my $logger = Log::Log4perl::get_logger("initialization");

#-----------------------------------------------------------------------------
# prepare RPC mapping

my $public = {};
my $rpc_hash = {};

for my $cat (qw/auth public/) {
  next if not exists $options->{"methods"}{$cat};
  for my $glob (@{ $options->{"methods"}{$cat} }) {
    for my $file (glob $glob) {
      $logger->debug("Loading $file");

      my $load = load_method($file);
      my $method_name = "$load->{schema}.$load->{method}";

      if ($cat eq 'public') {
        $public->{$method_name} = 1;
      }
      if (not exists $rpc_hash->{$method_name}) {
        $rpc_hash->{$method_name} = $load->{"proc"};
      }
    }
  }
}

#-----------------------------------------------------------------------------
# prepare authentication subsystem

my $auth = new Authen::Simple(
  auth_module_init($options->{'auth_method'}, $options->{'auth_params'})
);

#-----------------------------------------------------------------------------

$logger = Log::Log4perl::get_logger("server");

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $options->{"ssl_cert_file"},
  SSL_key_file  => $options->{"ssl_key_file"},
  LocalPort => $options->{"listen_port"},
  LocalAddr => $options->{"listen_addr"},
  Listen => 1,
  ReuseAddr => 1,
) or $logger->logdie("Socket listening error: ", $!);

my $rpc_server = new Frontier::RPC2();

my $workers = new Proc::Queue();
$SIG{CHLD} = sub { $workers->reap };
$SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub {
  my ($signal) = @_;

  my $logger = Log::Log4perl::get_logger("server");
  $logger->info("Terminating on signal ", $signal);

  $workers->killall;
  exit;
};

# I don't care about broken pipe (mostly communication with connecting agents)
$SIG{PIPE} = 'IGNORE';

CLIENT:
while (1) {
  my $client = $daemon->accept or next CLIENT;

  if ($workers->spawn == 0) {
    # when daemon gets restarted while some client was processed, (new) daemon
    # will be able to listen() on the socket
    close $daemon;
    # in child process, `` should return status in $? variable normally
    $SIG{CHLD} = "DEFAULT";
    process_client($client, $auth, $rpc_server, $rpc_hash, $public);
    exit 0;
  }
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

sub process_client {
  my ($client, $auth, $rpc_server, $rpc_hash, $public) = @_;

  # on SIGTERM client handler should finish processing current request and
  # THEN exit
  my $continue_processing = 1;
  $SIG{TERM} = $SIG{INT} = $SIG{HUP} = sub { $continue_processing = 0 };

  my $logger = Log::Log4perl::get_logger("client");

  REQUEST:
  while ($continue_processing && (my $req = $client->get_request)) {
    $logger->debug("Another request");

    if ($req->method ne 'POST') {
      $logger->info("HTTP request ", $req->method, ": denying");
      $client->send_error(RC_FORBIDDEN);
      next REQUEST;
    }

    my $req_decoded = $rpc_server->decode($req->content);

    if (not $public->{$req_decoded->{method_name}}) {
      # XXX: authenticate if method was not marked as public

      $logger->debug("Request for ", $req_decoded->{method_name},
                     " requires authentication");

      my $auth_user = authenticate($req, $auth);
      if (not defined $auth_user) {
        $logger->debug("Unauthorized request");
        my $resp = new HTTP::Response(401, 'Unauthorized');
        $resp->header('WWW-Authenticate' => 'Basic realm=""');

        $client->send_response($resp);
        next REQUEST;
      }

      $logger->debug("Request authorized (user ", $auth_user, ")");
    }

    my $xml_resp = $rpc_server->serve($req->content, $rpc_hash);

    my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

    $client->send_response($resp);
  }
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req, $auth) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  my $logger = Log::Log4perl::get_logger("auth");

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  $logger->debug("Requested user: ", $user);
  if ($auth->authenticate($user, $pass)) {
    $logger->debug("Authentication success");
    return $user;
  }

  return undef;
}

#-----------------------------------------------------------------------------

sub auth_module_init {
  my ($module, $options) = @_;

  die "Undefined authentication module name" if not defined $module;
  if ($module !~ /^[a-zA-Z_0-9:]+$/) {
    die "Invalid authentication module name: $module";
  }

  my $instance;
  eval "
    require $module;
    \$instance = ${module}->new(%\$options);
  ";
  die $@ if $@;

  return $instance;
}

#-----------------------------------------------------------------------------

sub load_method {
  my ($path) = @_;

  my $package = $path;
  $package =~ s/\.pm$//;

  ($package, my $method) = (split m[/+], $package)[-2, -1];

  if ("${package}::${method}" !~ /^[a-zA-Z0-9_]+::[a-zA-Z0-9_]+$/) {
    die "Path $path translates into incorrect package name: ${package}::${method}";
  }

  my $sub;
  eval "
    package rpcmethod::$package;
    require \$path;
    \$sub = \\&entry_point;
  ";
  die $@ if $@;

  return {
    schema => $package,
    method => $method,
    proc   => $sub,
  };
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

package Proc::Queue;

use POSIX qw/:sys_wait_h/;

sub new {
  my ($class, %args) = @_;

  my $self = {
    queue => [],
    max_len => int($args{max_len} || 0),
  };

  return bless $self, $class;
}

sub killall {
  my ($self, $signal) = @_;

  if (not defined $signal) {
    $signal = 'TERM';
  }

  kill $signal, @{ $self->{queue} };
  $self->reap;
}

sub reap {
  my ($self) = @_;

  CHILD:
  while ((my $kid = waitpid(-1, WNOHANG)) > 0) {
    #if ($? != 0) {
    #  printf STDERR "Error code: %d (signal %d)\n", $? >> 8, $? & 0xff;
    #}
    for (my $i = 0; $i < @{ $self->{queue} }; ++$i) {
      if ($self->{queue}[$i] == $kid) {
        splice @{ $self->{queue} }, $i, 1;
        next CHILD;
      }
    }
  }
}

sub spawn {
  my ($self) = @_;

  if ($self->{max_len} > 0) {
    while ($self->length >= $self->{max_len}) {
      sleep 1;
    }
  }

  my $pid = fork;
  if (not defined $pid) {
    die "Can't fork(): $!";
  }

  if ($pid > 0) {
    push @{ $self->{queue} }, $pid;
  }

  return $pid;
}

sub length {
  my ($self) = @_;

  return scalar @{ $self->{queue} };
}

#-----------------------------------------------------------------------------
# vim:ft=perl
