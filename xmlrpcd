#!/usr/bin/perl

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

#-----------------------------------------------------------------------------

my $cert = 'x509/actual.cert.pem';
my $key  = 'x509/actual.key.pem';

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $cert,
  SSL_key_file  => $key,
  LocalPort => 1638,
  #LocalAddr => 'localhost',
  Listen => 1,
  ReuseAddr => 1,
) or die "$!";

my $rpc_server = new Frontier::RPC2();
my $rpc_hash = {
  'sample.sumAndDifference' => sub {
    my ($a, $b) = @_;
    return [$a + $b, $a - $b];
  },
};

CLIENT:
while (1) {
  my $c = $daemon->accept or next CLIENT;
  REQUEST:
  while (my $req = $c->get_request) {
    if ($req->method ne 'POST') {
      $c->send_error(RC_FORBIDDEN);
    }

    # XXX: authenticate
    my $auth_user = authenticate($req);
    if (not defined $auth_user) {
      my $resp = new HTTP::Response(401, 'Unauthorized');
      $resp->header('WWW-Authenticate' => 'Basic realm=""');

      $c->send_response($resp);
      next REQUEST;
    }

    my $xml_resp = $rpc_server->serve(
      $req->content,
      $rpc_hash,
    );

    my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

    $c->send_response($resp);
  }
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  print "user: $user | pass: $pass\n";

  return $user;
}

#-----------------------------------------------------------------------------
# vim:ft=perl
