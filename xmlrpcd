#!/usr/bin/perl

use warnings;
use strict;

use IO::Socket::SSL;
use HTTP::Daemon::SSL;
use HTTP::Status;
use MIME::Base64;

use Frontier::RPC2;

use YAML qw/LoadFile/;

use App::Daemon qw/daemonize/;
use Log::Log4perl;
use Authen::Simple;

#-----------------------------------------------------------------------------
# load configuration

$App::Daemon::pidfile = 'run/xmlrpcd.pid';
$App::Daemon::l4p_conf = 'logging.conf';

my $options = {};

my $opts_file = App::Daemon::find_option("--config" => 1);
if (defined $opts_file) {
  $options = LoadFile($opts_file);
}

#-----------------------------------------------------------------------------

daemonize();

my $logger = Log::Log4perl::get_logger("initialization");

#-----------------------------------------------------------------------------
# prepare RPC mapping

my $rpc_hash = {};

for my $glob (@{ $options->{"methods"} }) {
  for my $file (glob $glob) {
    $logger->debug("Loading $file");

    my $load = load_method($file);
    $rpc_hash->{"$load->{schema}.$load->{method}"} = $load->{"proc"};
  }
}

#-----------------------------------------------------------------------------
# prepare authentication subsystem

my $auth = new Authen::Simple(
  auth_module_init($options->{'auth_method'}, $options->{'auth_params'})
);

#-----------------------------------------------------------------------------

$logger = Log::Log4perl::get_logger("http");

my $daemon = new HTTP::Daemon::SSL(
  SSL_cert_file => $options->{"ssl_cert_file"},
  SSL_key_file  => $options->{"ssl_key_file"},
  LocalPort => $options->{"listen_port"},
  LocalAddr => $options->{"listen_addr"},
  Listen => 1,
  ReuseAddr => 1,
) or $logger->logdie("Socket listening error: ", $!);

my $rpc_server = new Frontier::RPC2();

CLIENT:
while (1) {
  my $client = $daemon->accept or next CLIENT;

  process_client($client, $auth, $rpc_server, $rpc_hash);
}

#-----------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------

sub process_client {
  my ($client, $auth, $rpc_server, $rpc_hash) = @_;

  my $logger = Log::Log4perl::get_logger("client");

  REQUEST:
  while (my $req = $client->get_request) {
    $logger->debug("Another request");

    if ($req->method ne 'POST') {
      $logger->info("HTTP request ", $req->method, ": denying");
      $client->send_error(RC_FORBIDDEN);
      next REQUEST;
    }

    # XXX: authenticate
    my $auth_user = authenticate($req, $auth);
    if (not defined $auth_user) {
      $logger->debug("Unauthorized request");
      my $resp = new HTTP::Response(401, 'Unauthorized');
      $resp->header('WWW-Authenticate' => 'Basic realm=""');

      $client->send_response($resp);
      next REQUEST;
    }

    $logger->debug("Request authorized (user ", $auth_user, ")");

    my $xml_resp = $rpc_server->serve(
      $req->content,
      $rpc_hash,
    );

    my $resp = new HTTP::Response(200, 'OK', undef, $xml_resp);

    $client->send_response($resp);
  }
}

#-----------------------------------------------------------------------------

sub authenticate {
  my ($req, $auth) = @_;

  my $auth_data = $req->header('Authorization');
  if (not defined $auth_data or
      $auth_data !~ s/^Basic (\S+).*/$1/i) {
    return undef;
  }

  my $logger = Log::Log4perl::get_logger("auth");

  # Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
  # username:password
  my ($user, $pass) = split /:/, decode_base64($auth_data), 2;

  $logger->debug("Requested user: ", $user);
  if ($auth->authenticate($user, $pass)) {
    $logger->debug("Authentication success");
    return $user;
  }

  return undef;
}

#-----------------------------------------------------------------------------

sub auth_module_init {
  my ($module, $options) = @_;

  die "Undefined authentication module name" if not defined $module;
  if ($module !~ /^[a-zA-Z_0-9:]+$/) {
    die "Invalid authentication module name: $module";
  }

  my $instance;
  eval "
    require $module;
    \$instance = ${module}->new(%\$options);
  ";
  die $@ if $@;

  return $instance;
}

#-----------------------------------------------------------------------------

sub load_method {
  my ($path) = @_;

  my $package = $path;
  $package =~ s/\.pm$//;

  ($package, my $method) = (split m[/+], $package)[-2, -1];

  if ("${package}::${method}" !~ /^[a-zA-Z0-9_]+::[a-zA-Z0-9_]+$/) {
    die "Path $path translates into incorrect package name: ${package}::${method}";
  }

  my $sub;
  eval "
    package rpcmethod::$package;
    require \$path;
    \$sub = \\&entry_point;
  ";
  die $@ if $@;

  return {
    schema => $package,
    method => $method,
    proc   => $sub,
  };
}

#-----------------------------------------------------------------------------
# vim:ft=perl
