#!/usr/bin/perl

use warnings;
use strict;

use constant {
  MAX_SIMULTANEOUS_CALLS => 8,
};

# XXX: IO::Socket::SSL must be loaded before LWP::UserAgent, so the latter
# uses that instead of Net::SSL. Load them at the very beginning, just to make
# sure none of the other modules messes with this.
use IO::Socket::SSL;
use LWP::UserAgent;

use Frontier::Client;

use YAML qw/LoadFile/;
use Getopt::Long::Descriptive;

use POSIX;
use URI;
use List::Util qw/first/;

#-----------------------------------------------------------------------------
# default parameters {{{

my %defaults = (
  hostname  => undef,
  port      => 3033,
  username  => undef,
  password  => undef,
  ca_file   => undef,
  ca_ignore => 'false',
  verify_hostname => 'true',
);
my @callees = ();

my $config = first { -f && -r _ } "$ENV{HOME}/.xmlrpcaller.conf",
                                  '/etc/xmlrpcd/xmlrpcaller.conf';

my %call_options = (
  print_yaml => 'true',   # false if caller wants to print scalar
  multicall  => undef,    # called multiple hosts

  username   => undef,    # HTTP username common to all hosts in this call
  password   => undef,    # HTTP password common to all hosts in this call
);

# }}}
#-----------------------------------------------------------------------------
# parse command line options {{{

my @options = (
  [ "help"         => "this message" ],
  [ "config=s"     => "path to configuration file" ],
  [ "section=s"    => "which host description from config to use" ],
  [ "host=s"       => "RPC server address" ],
  [ "url=s"        => "URL of server address (replaces host and port, but not user nor password)" ],
  [ "username=s"   => "username for HTTP authentication (you'll be prompted for password)" ],
  [ "port=i"       => "RPC server port (default: $defaults{port})" ],
  [ "ca-file=s"    => "path to CA file" ],
  [ "skip-ca!"     => "whether verify SSL certificate or not (default: no-skip)" ],
  [ "verify!"      => "whether verify hostname with cert or not (default: verify)" ],
  [ "print"        => "just print the returned element as string (fail if RPC returned many elements or non-string)" ],
  [ "params=s"     => "YAML file containing all the parameters to remote subroutine (replacement for specifying them in command line)" ],
);
my ($cmdlineopts, $usage) = describe_options(
  "Usage: %c %o package.method arg1 arg2 ...",
  @options,
);

if ($cmdlineopts->{help}) {
  print $usage;
  print "\n";
  print "NOTE: there's no way to specify password in command line. Use config.\n";
  exit;
}

if ($cmdlineopts->{'print'}) {
  $call_options{print_yaml} = undef;
}

if ($cmdlineopts->{'params'}) {
  @ARGV = ($ARGV[0], YAML::LoadFile($cmdlineopts->{'params'}));
}

# }}}
#-----------------------------------------------------------------------------
# determine who to connect and with what credentials {{{
#-----------------------------------------------------------------------------
# read callee parameters from config file

if (defined $cmdlineopts->{config}) {
  $config = $cmdlineopts->{config};
}

if (defined $cmdlineopts->{section}) {
  if (not defined $config) {
    die "No default config file could be read and none specified in command line\n";
  }
  my $options = LoadFile($config);
  $options = $options->{'xmlrpcaller'};

  my $section = $options->{ $cmdlineopts->{section} };

  if (ref($section) eq 'ARRAY') {
    $call_options{multicall} = 'true';
    @callees = @$section;
  } elsif (ref($section) eq 'HASH') {
    $call_options{multicall} = undef;
    $callees[0] = $section;
  }
} elsif (defined $cmdlineopts->{host} || defined $cmdlineopts->{url}) {
  # everything will be filled by add_cmdline_params()
  $callees[0] = {};
}

#-----------------------------------------------------------------------------
# prepare callee parameters regarding defaults and command line overrides

my %users_for_password;
for my $host (@callees) {
  # this will add default host parameters
  %$host = ( %defaults, %$host, );

  add_cmdline_params($host, $cmdlineopts);
  if (defined $host->{username} && !defined $host->{password}) {
    $users_for_password{$host->{username}} = 1;
  }
}

if (@callees == 0) {
  die "No hosts specified to call\n";
}

#-----------------------------------------------------------------------------
# read password from terminal, if necessary

if (defined $cmdlineopts->{username}) {
  # if --username option was specified, this user/pass pair will override
  # config-specified ones

  my $user = $cmdlineopts->{username};
  my $pass;

  if ($call_options{multicall}) {
    $pass = ask_pass("Enter password for $user\@[$cmdlineopts->{section}]: ");
  } else {
    $pass = ask_pass("Enter password for $user\@$callees[0]{hostname}: ");
  }

  $call_options{username} = $user;
  $call_options{password} = $pass;
} elsif (keys %users_for_password > 1) {
  # multiple different users without password are not allowed

  die "Multiple usernames without passwords specified in section $cmdlineopts->{section}\n";
} elsif (%users_for_password) {
  # there's only one user without password (possibly multiple times) in the
  # section

  my $user = (keys %users_for_password)[0]; # XXX: there's just one key here
  my $pass = ask_pass("Enter password for $user\@[$cmdlineopts->{section}]: ");

  for my $host (@callees) {
    if (defined $host->{username} && $host->{username} eq $user &&
        !defined $host->{password}) {
      $host->{password} = $pass;
    }
  }
}

# }}}
#-----------------------------------------------------------------------------

if ($call_options{multicall}) {
  # multiple hosts called

  my %results = multicall(@callees);
  print YAML::Dump(\%results);

} else {
  # single host call

  my $host = $callees[0];

  my @results = singlecall($host);

  if ($call_options{print_yaml}) {
    print YAML::Dump @results;
  } else {
    if (@results > 1) {
      die sprintf "Remote call (%s:%d->%s) returned %d elements\n",
                  $host->{hostname}, $host->{port}, $ARGV[0],
                  scalar @results;
    }

    if (@results && ref($results[0]) ne '') {
      die sprintf "Remote call (%s:%d->%s) returned element of type %s\n",
                  $host->{hostname}, $host->{port}, $ARGV[0],
                  ref $results[0];
    }

    printf "%s\n", $results[0] if @results;
  }
}

#-----------------------------------------------------------------------------
#
# utility functions and modules
#
#-----------------------------------------------------------------------------
# command line parsing support {{{
#-----------------------------------------------------------------------------
# function to fill hash with connection params with overwrites coming from
# command line

# NOTE: side effects
sub add_cmdline_params { # {{{
  my ($params, $cmdlineopts) = @_;

  # 'internal parameter name' => 'command line option'
  my %translate = (
    hostname  => 'host',
    port      => 'port',
    url       => 'url',
    ca_file   => 'ca_file',
    ca_ignore => 'skip_ca',
    verify_hostname => 'verify',
  );

  for my $k (keys %translate) {
    if (defined $cmdlineopts->{ $translate{$k} }) {
      $params->{$k} = $cmdlineopts->{ $translate{$k} };
    }
  }
  $params->{path} = ""; # XXX: this can only be set by --url option

  # overwrite host/port if URL was provided
  if ($params->{url}) {
    my $url = new URI($params->{url});
    if ($url->scheme ne 'https') {
      die sprintf "Uknown scheme: %s for URL %s\n",
                  $url->scheme, $params->{url};
    }
    $params->{hostname} = $url->host;
    $params->{port} = $url->port;
    $params->{path} = $url->path_query;
    $params->{path} =~ s{^/}{};
  }

  # normalize boolean options
  for my $bool_opt (qw/ca_ignore verify_hostname/) {
    if ($params->{$bool_opt} =~ /^false$/i or not $params->{$bool_opt}) {
      $params->{$bool_opt} = undef;
    } else {
      $params->{$bool_opt} = 'true';
    }
  }

  if ($params->{ca_ignore}) {
    delete $params->{ca_file};
  }

  if (not defined $params->{hostname}) {
    die "No hostname provided\n";
  }
  if (not defined $params->{port}) {
    die "No port specified for $params->{hostname}\n";
  }
  if (!$params->{ca_ignore} && !defined $params->{ca_file} ) {
    die "No CA specified for $params->{hostname}\n";
  }
} # }}}

#-----------------------------------------------------------------------------
# reading password from terminal

sub ask_pass { # {{{
  my ($prompt) = @_;
  $prompt ||= "Enter password: ";

  my $term = new POSIX::Termios;
  $term->getattr(fileno STDIN);
  my $attrs = $term->getlflag;

  $term->setlflag($attrs & ~&POSIX::ECHO);
  $term->setattr(fileno STDIN, &POSIX::TCSANOW);

  printf STDERR "%s", $prompt;
  my $pass = <STDIN>;
  chomp $pass;
  printf STDERR "\n";

  $term->setlflag($attrs);
  $term->setattr(fileno STDIN, &POSIX::TCSANOW);

  return $pass;
} # }}}

# }}}
#-----------------------------------------------------------------------------
# XML-RPC call support {{{
#-----------------------------------------------------------------------------

sub singlecall { # {{{
  my ($host) = @_;

  # replace user/pass possibly coming from config file
  my %common_user_pass;
  if (defined $call_options{username} && defined $call_options{password}) {
    %common_user_pass = (
      username => $call_options{username},
      password => $call_options{password},
    );
  }

  my @results = xmlrpcall(%$host, %common_user_pass);
  return @results;
} # }}}

#-----------------------------------------------------------------------------

sub multicall { # {{{
  my (@hosts) = @_;

  # replace user/pass possibly coming from config file
  my %common_user_pass;
  if (defined $call_options{username} && defined $call_options{password}) {
    %common_user_pass = (
      username => $call_options{username},
      password => $call_options{password},
    );
  }

  my $spool = Worker::Spool->new(
    task => sub {
      my ($host) = @_;
      $0 = "[xmlrpcaller $host->{hostname}]"; # this looks nice in `ps -f'
      print YAML::Dump(
        xmlrpcall(%$host, %common_user_pass)
      );
    },
  );
  my @results = $spool->natatime(MAX_SIMULTANEOUS_CALLS, @hosts);

  my %results;
  for my $r (@results) {
    my $h = $results{ $r->{args}[0]{hostname} } = {
      hostname => $r->{args}[0]{hostname},
    };
    if (defined $r->{result}{exit_status}) {
      $h->{exit_code} = $r->{result}{exit_status};
    }
    if (defined $r->{result}{signal}) {
      $h->{signal} = $r->{result}{signal};
    }
    if (defined $r->{result}{stdout}) {
      $h->{data} = YAML::Load($r->{result}{stdout});
    }
    if (defined $r->{result}{stderr}) {
      $h->{error} = $r->{result}{stderr};
    }
  }
  return %results;
} # }}}

#-----------------------------------------------------------------------------
# actual XML-RPC call

# args:
#   hostname -\
#   port     -- all these form URL to connect to
#   path     -/
#   ca_file  - undef if going to be skipped
#   verify_hostname
#   username
#   password
sub xmlrpcall { # {{{
  my (%params) = @_;

  set_ssl_defaults($params{ca_file}, $params{verify_hostname});

  my $server = new Frontier::Client(
    url => sprintf "https://%s:%d/%s",
                   $params{hostname}, $params{port}, $params{path}
  );

  if (defined $params{username} && defined $params{password}) {
    # XXX: this is kinda hack on Frontier::Client, but there's no way to pass
    # UA or credentials
    bless $server->{ua}, "LWP::UserAgent::XMLRPC";
    $server->{ua}->xmlrpcd_store_credentials(
      $params{username}, $params{password},
    );
  }

  my @results = $server->call(@ARGV);

  return @results;
} # }}}

# }}}
#-----------------------------------------------------------------------------
# IO::Socket::SSL helper {{{

# if CA is meant to be ignored, $ca_file should be undef
sub set_ssl_defaults {
  my ($ca_file, $verify_hostname) = @_;

  IO::Socket::SSL::set_ctx_defaults(
    verify_mode => (
      defined $ca_file ?
        Net::SSLeay->VERIFY_PEER() :
        Net::SSLeay->VERIFY_NONE()
    ),
    ca_file => $ca_file,
    verifycn_scheme => ($verify_hostname ? 'http' : undef),
  );
}

# }}}
#-----------------------------------------------------------------------------
# LWP::UserAgent subclass for simplifying HTTP authentication {{{

package LWP::UserAgent::XMLRPC;

use base qw{LWP::UserAgent};

sub credentials {
  my ($self, @others) = @_;

  if (@others == 2) {
    return $self->get_basic_credentials(@others)
  } else {
    return $self->xmlrpcd_store_credentials(@others);
  }
}

sub xmlrpcd_store_credentials {
  my ($self, $user, $pass) = @_[0, -2, -1];

  if (@_ == 3) {
    $self->{basic_authentication} = [$user, $pass];
  } else {
    my ($loc, $realm) = @_[1, 2];
    $self->{basic_authentication} = {
      lc($loc) => { $realm => [$user, $pass] }
    };
  }
}

sub get_basic_credentials {
  my ($self, $realm, $uri, $isproxy) = @_;

  return if $isproxy;
  $uri = lc $uri;

  if (ref($self->{basic_authentication}) eq "ARRAY") {
    return @{ $self->{basic_authentication} };
  }

  if (exists $self->{basic_authentication}{$uri}{$realm}) {
    return @{ $self->{basic_authentication}{$uri}{$realm} };
  }

  return ();
}

# }}}
#-----------------------------------------------------------------------------
# worker subprocesses spool class {{{

package Worker::Spool;

use IO::Poll;

#-----------------------------------------------------------------------------
# public methods {{{
#-----------------------------------------------------------------------------

sub new {
  my ($class, %args) = @_;

  my $self = {
    poll => new IO::Poll(),
    task => undef,
    %args,
    filehq => {}, # empty hash; will contain Worker::Spool::Child as values
    pidq   => {}, # empty hash; will contain Worker::Spool::Child as values
  };

  die "No task given" if ref $self->{task} ne "CODE";

  return bless $self, $class;
}

#-----------------------------------------------------------------------------

sub natatime {
  my ($self, $n, @args) = @_;

  if ($n > @args) {
    $n = @args;
  }

  # make sure the SIGCHLD is not ignored or something
  local $SIG{CHLD} = "DEFAULT";

  # deliver common signals to children
  local $SIG{HUP} = local $SIG{INT} = local $SIG{TERM} = sub {
    $self->_kill($_[0]);
    die "Signal $_[0] catched\n";
  };

  # I'll gladly do `shift @args', but that would be ineffective
  my @todo = reverse @args;
  my @results;

  # fill in first $n tasks
  for (1 .. $n) {
    my $arg = pop @todo;
    # just for convenience, to call natatime(4, {}, {}, {}, ...) instead of
    # redundant [{}] (though that would do, as well)
    if (ref $arg eq 'ARRAY') {
      push @results, $self->_spawn(@$arg);
    } else {
      push @results, $self->_spawn($arg);
    }
  }

  # until both children list and tasks to do are empty
  while ($self->_has_children || @todo) {
    my $tasks_finished = $self->_wait_for_task;

    # for each finished task, spawn another one
    while (@todo && $tasks_finished--) {
      my $arg = pop @todo;
      if (ref $arg eq 'ARRAY') {
        push @results, $self->_spawn(@$arg);
      } else {
        push @results, $self->_spawn($arg);
      }
    }
  }

  return map { { %$_ } } @results;
}

#-----------------------------------------------------------------------------
# }}}
#-----------------------------------------------------------------------------
# private methods {{{
#-----------------------------------------------------------------------------

sub _has_children {
  my ($self) = @_;

  return scalar %{ $self->{pidq} };
}

sub _nchildren {
  my ($self) = @_;

  return scalar keys %{ $self->{pidq} };
}

#-----------------------------------------------------------------------------

sub _spawn {
  my ($self, @args) = @_;

  pipe my ($stdout_r, $stdout_w);
  pipe my ($stderr_r, $stderr_w);

  my $pid = fork;
  if (not defined $pid) {
    die "Can't fork(): $!";
  }

  if ($pid == 0) {
    $| = 1; # turn on autoflush

    # remove information on all queues and mappings (they won't be used in
    # this process)
    delete $self->{poll};
    delete $self->{pidq};
    delete $self->{filehq};

    # set signal handlers to default
    $SIG{HUP} = $SIG{INT} = $SIG{TERM} = "DEFAULT";

    # dup2()
    open STDIN, "<", "/dev/null"; # no input for task
    open STDOUT, ">&", $stdout_w;
    open STDERR, ">&", $stderr_w;
    # close unnecessary file handles
    close $_ for $stdout_r, $stderr_r, $stdout_w, $stderr_w;

    # call task and exit
    $self->{task}(@args);
    exit 0;
  }

  # now this is the parent process
  close $_ for $stdout_w, $stderr_w;

  my $child = Worker::Spool::Child->new(
    pid    => $pid,
    stdout => $stdout_r,
    stderr => $stderr_r,
    args   => \@args,
  );

  $self->_add($child);

  return $child;
}

#-----------------------------------------------------------------------------

sub _wait_for_task {
  my ($self) = @_;

  # no need to wait for an event if no children
  return if not $self->_has_children;

  my $finished = 0;
  my $nevents = $self->{poll}->poll; # wait infinitely
  my @events = $self->{poll}->handles(POLLIN);
  my @errors = $self->{poll}->handles(POLLERR | POLLHUP | POLLNVAL);

  for my $e (@events, @errors) {
    if (not exists $self->{filehq}{$e}) {
      # XXX: child was probably(?) removed earlier in this loop; just skip
      # this event
      next;
      #die "ERROR! I have no information in queue on file handle $e!";
    }

    my $child = $self->{filehq}{$e};

    # remove kid from all queues
    $self->_remove($child);

    # XXX: child will close both read handles
    $child->read($e);
    ++$finished;
  }

  return $finished;
}

#-----------------------------------------------------------------------------

sub _kill {
  my ($self, $signal) = @_;

  kill $signal || "TERM", keys %{ $self->{pidq} };
}

#-----------------------------------------------------------------------------

sub _add {
  my ($self, $child) = @_;

  # mapping filehandle => kid
  $self->{filehq}{ $child->{stdout} } = $child;
  $self->{filehq}{ $child->{stderr} } = $child;

  # mapping PID => kid
  $self->{pidq}{ $child->{pid} } = $child;

  # IO::Poll
  $self->{poll}->mask($child->{stdout} => POLLIN);
  $self->{poll}->mask($child->{stderr} => POLLIN);
}

#-----------------------------------------------------------------------------

sub _remove {
  my ($self, $child) = @_;

  # IO::Poll
  $self->{poll}->remove($child->{stdout});
  $self->{poll}->remove($child->{stderr});

  # mapping filehandle => kid
  delete $self->{filehq}{ $child->{stdout} };
  delete $self->{filehq}{ $child->{stderr} };

  # mapping PID => kid
  delete $self->{pidq}{ $child->{pid} };
}

# }}}
#-----------------------------------------------------------------------------
# }}}
#-----------------------------------------------------------------------------
# worker child process class {{{

package Worker::Spool::Child;

use POSIX qw{WIFEXITED WEXITSTATUS WIFSIGNALED WTERMSIG};
use List::Util qw{first};

#-----------------------------------------------------------------------------

sub new {
  my ($class, %args) = @_;

  my $self = { %args };
  # pid     INT
  # stdout  FD
  # stderr  FD
  # host    STRING

  return bless $self, $class;
}

sub read {
  my ($self, $fd) = @_;

  my $dest = first { $fd eq $self->{$_} } qw{stdout stderr};
  die "Invalid file handle" if not defined $dest;

  my $output = do { local $/ = undef; <$fd> };
  # in case the child exited without printing anything
  if ($dest eq 'stderr' && $output eq '') {
    $dest = 'stdout';
  }
  $self->{result} = { $dest => $output };

  waitpid $self->{pid}, 0;
  delete $self->{pid};
  if (WIFEXITED($?)) {
    $self->{result}{exit_status} = WEXITSTATUS($?);
  } elsif (WIFSIGNALED($?)) {
    $self->{result}{signal} = WTERMSIG($?);
  }

  close $self->{stdout};
  close $self->{stderr};
  delete $self->{stdout};
  delete $self->{stderr};
}

sub finished {
  my ($self) = @_;

  return defined $self->{result};
}

sub result {
  my ($self) = @_;

  return $self->{result};
}

# }}}
#-----------------------------------------------------------------------------
# vim:ft=perl:foldmethod=marker:nowrap
