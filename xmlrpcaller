#!/usr/bin/perl

use warnings;
use strict;

# XXX: IO::Socket::SSL must be loaded before LWP::UserAgent, so the latter
# uses that instead of Net::SSL. Load them at the very beginning, just to make
# sure none of the other modules messes with this.
use IO::Socket::SSL;
use LWP::UserAgent;

use YAML qw/LoadFile/;
use Getopt::Long::Descriptive;
use List::Util qw/first/;

use POSIX;

use Frontier::Client;

use URI;

#-----------------------------------------------------------------------------
# fill some defaults

my %defaults = (
  hostname  => undef,
  port      => 3033,
  username  => undef,
  password  => undef,
  ca_file   => undef,
  ca_ignore => 'false',
  verify_hostname => 'true',
);
my @callees = ();

my $config = first { -f && -r _ } "$ENV{HOME}/.xmlrpcaller.conf",
                                  '/etc/xmlrpcd/xmlrpcaller.conf';

my %call_options = (
  print_yaml => 'true',   # false if caller wants to print scalar
  multicall  => undef,    # called multiple hosts

  username   => undef,    # HTTP username common to all hosts in this call
  password   => undef,    # HTTP password common to all hosts in this call
);

#-----------------------------------------------------------------------------
# parse command line options

my @options = (
  [ "help"         => "this message" ],
  [ "config=s"     => "path to configuration file" ],
  [ "section=s"    => "which host description from config to use" ],
  [ "host=s"       => "RPC server address" ],
  [ "url=s"        => "URL of server address (replaces host and port, but not user nor password)" ],
  [ "username=s"   => "username for HTTP authentication (you'll be prompted for password)" ],
  [ "port=i"       => "RPC server port (default: $defaults{port})" ],
  [ "ca-file=s"    => "path to CA file" ],
  [ "skip-ca!"     => "whether verify SSL certificate or not (default: no-skip)" ],
  [ "verify!"      => "whether verify hostname with cert or not (default: verify)" ],
  [ "print"        => "just print the returned element as string (fail if RPC returned many elements or non-string)" ],
  [ "params=s"     => "YAML file containing all the parameters to remote subroutine (replacement for specifying them in command line)" ],
);
my ($cmdlineopts, $usage) = describe_options(
  "Usage: %c %o package.method arg1 arg2 ...",
  @options,
);

if ($cmdlineopts->{help}) {
  print $usage;
  print "\n";
  print "NOTE: there's no way to specify password in command line. Use config.\n";
  exit;
}

if ($cmdlineopts->{'print'}) {
  $call_options{print_yaml} = undef;
}

if ($cmdlineopts->{'params'}) {
  @ARGV = ($ARGV[0], YAML::LoadFile($cmdlineopts->{'params'}));
}

#-----------------------------------------------------------------------------
# read configuration file

if (defined $cmdlineopts->{config}) {
  $config = $cmdlineopts->{config};
}

if (defined $cmdlineopts->{section}) {
  if (not defined $config) {
    die "No default config file could be read and none specified in command line\n";
  }
  my $options = LoadFile($config);
  $options = $options->{'xmlrpcaller'};

  my $section = $options->{ $cmdlineopts->{section} };

  if (ref($section) eq 'ARRAY') {
    $call_options{multicall} = 'true';
    @callees = @$section;
  } elsif (ref($section) eq 'HASH') {
    $call_options{multicall} = undef;
    $callees[0] = $section;
  }
} elsif (defined $cmdlineopts->{host} || defined $cmdlineopts->{url}) {
  # everything will be filled by add_cmdline_params()
  $callees[0] = {};
}

#-----------------------------------------------------------------------------
# fill in host parameters

my %users_for_password;
for my $host (@callees) {
  # this will add default host parameters
  %$host = ( %defaults, %$host, );

  add_cmdline_params($host, $cmdlineopts);
  if (defined $host->{username} && !defined $host->{password}) {
    $users_for_password{$host->{username}} = 1;
  }
}

if (@callees == 0) {
  die "No hosts specified to call\n";
}

#-----------------------------------------------------------------------------
# read password from terminal

if (defined $cmdlineopts->{username}) {
  # if --username option was specified, this user/pass pair will override
  # config-specified ones

  my $user = $cmdlineopts->{username};
  my $pass;

  if ($call_options{multicall}) {
    $pass = ask_pass("Enter password for $user\@[$cmdlineopts->{section}]: ");
  } else {
    $pass = ask_pass("Enter password for $user\@$callees[0]{hostname}: ");
  }

  $call_options{username} = $user;
  $call_options{password} = $pass;
} elsif (keys %users_for_password > 1) {
  # multiple different users without password are not allowed

  die "Multiple usernames without passwords specified in section $cmdlineopts->{section}\n";
} elsif (%users_for_password) {
  # there's only one user without password (possibly multiple times) in the
  # section

  my $user = (keys %users_for_password)[0]; # XXX: there's just one key here
  my $pass = ask_pass("Enter password for $user\@[$cmdlineopts->{section}]: ");

  for my $host (@callees) {
    if (defined $host->{username} && $host->{username} eq $user &&
        !defined $host->{password}) {
      $host->{password} = $pass;
    }
  }
}

#-----------------------------------------------------------------------------

if ($call_options{multicall}) {
  # multiple hosts called

  my %results = multicall(@callees);
  print YAML::Dump(\%results);

} else {
  # single host call

  my $host = $callees[0];

  my @results = singlecall($host);

  if ($call_options{print_yaml}) {
    print YAML::Dump @results;
  } else {
    if (@results > 1) {
      die sprintf "Remote call (%s:%d->%s) returned %d elements\n",
                  $host->{hostname}, $host->{port}, $ARGV[0],
                  scalar @results;
    }

    if (@results && ref($results[0]) ne '') {
      die sprintf "Remote call (%s:%d->%s) returned element of type %s\n",
                  $host->{hostname}, $host->{port}, $ARGV[0],
                  ref $results[0];
    }

    printf "%s\n", $results[0] if @results;
  }
}

#-----------------------------------------------------------------------------
#
# utility functions
#
#-----------------------------------------------------------------------------

# NOTE: side effects
sub add_cmdline_params {
  my ($params, $cmdlineopts) = @_;

  # 'internal parameter name' => 'command line option'
  my %translate = (
    hostname  => 'host',
    port      => 'port',
    url       => 'url',
    ca_file   => 'ca_file',
    ca_ignore => 'skip_ca',
    verify_hostname => 'verify',
  );

  for my $k (keys %translate) {
    if (defined $cmdlineopts->{ $translate{$k} }) {
      $params->{$k} = $cmdlineopts->{ $translate{$k} };
    }
  }
  $params->{path} = ""; # XXX: this can only be set by --url option

  # overwrite host/port if URL was provided
  if ($params->{url}) {
    my $url = new URI($params->{url});
    if ($url->scheme ne 'https') {
      die sprintf "Uknown scheme: %s for URL %s\n",
                  $url->scheme, $params->{url};
    }
    $params->{hostname} = $url->host;
    $params->{port} = $url->port;
    $params->{path} = $url->path_query;
    $params->{path} =~ s{^/}{};
  }

  # normalize boolean options
  for my $bool_opt (qw/ca_ignore verify_hostname/) {
    if ($params->{$bool_opt} =~ /^false$/i or not $params->{$bool_opt}) {
      $params->{$bool_opt} = undef;
    } else {
      $params->{$bool_opt} = 'true';
    }
  }

  if ($params->{ca_ignore}) {
    delete $params->{ca_file};
  }

  if (not defined $params->{hostname}) {
    die "No hostname provided\n";
  }
  if (not defined $params->{port}) {
    die "No port specified for $params->{hostname}\n";
  }
  if (!$params->{ca_ignore} && !defined $params->{ca_file} ) {
    die "No CA specified for $params->{hostname}\n";
  }
}

#-----------------------------------------------------------------------------

# if CA is meant to be ignored, $ca_file should be undef
sub set_ssl_defaults {
  my ($ca_file, $verify_hostname) = @_;

  IO::Socket::SSL::set_ctx_defaults(
    verify_mode => (
      defined $ca_file ?
        Net::SSLeay->VERIFY_PEER() :
        Net::SSLeay->VERIFY_NONE()
    ),
    ca_file => $ca_file,
    verifycn_scheme => ($verify_hostname ? 'http' : undef),
  );
}

#-----------------------------------------------------------------------------

# args:
#   hostname -\
#   port     -- all these form URL to connect to
#   path     -/
#   ca_file  - undef if going to be skipped
#   verify_hostname
#   username
#   password
sub xmlrpcall {
  my (%params) = @_;

  set_ssl_defaults($params{ca_file}, $params{verify_hostname});

  my $server = new Frontier::Client(
    url => sprintf "https://%s:%d/%s",
                   $params{hostname}, $params{port}, $params{path}
  );

  if (defined $params{username} && defined $params{password}) {
    # XXX: this is kinda hack on Frontier::Client, but there's no way to pass
    # UA or credentials
    bless $server->{ua}, "LWP::UserAgent::XMLRPC";
    $server->{ua}->xmlrpcd_store_credentials(
      $params{username}, $params{password},
    );
  }

  my @results = $server->call(@ARGV);

  return @results;
}

#-----------------------------------------------------------------------------

sub singlecall {
  my ($host) = @_;

  my %common_user_pass;
  if (defined $call_options{username} &&
      defined $call_options{password}) {
    %common_user_pass = (
      username => $call_options{username},
      password => $call_options{password},
    );
  }

  my @results = xmlrpcall(%$host, %common_user_pass);
  return @results;
}

#-----------------------------------------------------------------------------

sub fork_call {
  my ($sub) = @_;

  my $pid;
  pipe my ($stdout_r, $stdout_w);
  pipe my ($stderr_r, $stderr_w);

  $pid = fork;
  if ($pid < -1) {
    die "fork() failed: $!";
  }

  # XXX: child process
  if ($pid == 0) {
    open STDIN, "<", "/dev/null"; # just to be sure
    open STDOUT, ">&", $stdout_w;
    open STDERR, ">&", $stderr_w;
    close $_ for $stdout_r, $stdout_w, $stderr_r, $stderr_w;

    $sub->();
    exit;
  }

  close $_ for $stdout_w, $stderr_w;
  return {
    stdout => $stdout_r,
    stderr => $stderr_r,
    pid => $pid,
  };
}

sub multicall {
  my (@hosts) = @_;

  my %common_user_pass;
  if (defined $call_options{username} &&
      defined $call_options{password}) {
    %common_user_pass = (
      username => $call_options{username},
      password => $call_options{password},
    );
  }

  use POSIX ":sys_wait_h";
  my %hosts;
  my $kids = 0;

  $SIG{CHLD} = sub {
    my $kid;
    while (1) {
      $kid = waitpid(-1, WNOHANG);
      last if $kid <= 0;

      $hosts{$kid}{exit_code} = $?;
      --$kids;
    }
  };

  use IO::Poll;
  my $poll = new IO::Poll();

  for my $host (@hosts) {
    my $child = fork_call(
      sub { print YAML::Dump(xmlrpcall(%$host, %common_user_pass)); }
    );
    $child->{hostname} = $host->{hostname};
    ++$kids;

    $hosts{$child->{pid}} = $child;
    $poll->mask($child->{stdout} => POLLIN);
    $poll->mask($child->{stderr} => POLLIN);
  }

  while ($poll->handles) {
    $poll->poll(1); # wait for 1s

    for my $kid (keys %hosts) {

      if (defined $hosts{$kid}{stdout} &&
          $poll->events($hosts{$kid}{stdout})) {
        my $fh = $hosts{$kid}{stdout};
        my $yaml = join '', <$fh>;
        $poll->remove($hosts{$kid}{stdout});
        delete $hosts{$kid}{stdout};

        if (defined $yaml && $yaml =~ /\S/) {
          $hosts{$kid}{"stdout_data"} = YAML::Load($yaml);
        }
      }

      if (defined $hosts{$kid}{stderr} &&
          $poll->events($hosts{$kid}{stderr})) {
        my $fh = $hosts{$kid}{stderr};
        my $data = join '', <$fh>;
        $poll->remove($hosts{$kid}{stderr});
        delete $hosts{$kid}{stderr};

        if (defined $data && $data =~ /\S/) {
          $hosts{$kid}{"stderr_data"} = $data;
        }
      }

    } # foreach (%kid)
  } # while ($poll->handles)

  # wait for all kids to finish
  while ($kids > 0) {
    select undef, undef, undef, 0.1;
  }

  return map {
    $hosts{$_}{hostname} => {
      hostname    => $hosts{$_}{hostname},
      exit_code   => $hosts{$_}{exit_code},
      data        => $hosts{$_}{stdout_data},
      error       => $hosts{$_}{stderr_data},
    }
  } keys %hosts;
}

#-----------------------------------------------------------------------------

sub ask_pass {
  my ($prompt) = @_;
  $prompt ||= "Enter password: ";

  my $term = new POSIX::Termios;
  $term->getattr(fileno STDIN);
  my $attrs = $term->getlflag;

  $term->setlflag($attrs & ~&POSIX::ECHO);
  $term->setattr(fileno STDIN, &POSIX::TCSANOW);

  printf STDERR "%s", $prompt;
  my $pass = <STDIN>;
  chomp $pass;
  printf STDERR "\n";

  $term->setlflag($attrs);
  $term->setattr(fileno STDIN, &POSIX::TCSANOW);

  return $pass;
}

#-----------------------------------------------------------------------------

package LWP::UserAgent::XMLRPC;

use base qw{LWP::UserAgent};

sub credentials {
  my ($self, @others) = @_;

  if (@others == 2) {
    return $self->get_basic_credentials(@others)
  } else {
    return $self->xmlrpcd_store_credentials(@others);
  }
}

sub xmlrpcd_store_credentials {
  my ($self, $user, $pass) = @_[0, -2, -1];

  if (@_ == 3) {
    $self->{basic_authentication} = [$user, $pass];
  } else {
    my ($loc, $realm) = @_[1, 2];
    $self->{basic_authentication} = {
      lc($loc) => { $realm => [$user, $pass] }
    };
  }
}

sub get_basic_credentials {
  my ($self, $realm, $uri, $isproxy) = @_;

  return if $isproxy;
  $uri = lc $uri;

  if (ref($self->{basic_authentication}) eq "ARRAY") {
    return @{ $self->{basic_authentication} };
  }

  if (exists $self->{basic_authentication}{$uri}{$realm}) {
    return @{ $self->{basic_authentication}{$uri}{$realm} };
  }

  return ();
}

#-----------------------------------------------------------------------------
# vim:ft=perl
